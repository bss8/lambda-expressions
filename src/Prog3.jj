/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Prog3.jj */
/*@egen*//**
 *
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.
 *
 */

options {
              // an option for JJTree
  STATIC=false;// set to build a multi mode tree
              // (with different types of nodes)

}

PARSER_BEGIN(Prog3)

class Prog3/*@bgen(jjtree)*/implements Prog3TreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTProg3State jjtree = new JJTProg3State();

/*@egen*/
  public static void main(String[] args) {
    System.out.println(">>> Lambda Expression Evaluator <<<");
	System.out.println("Enter an applied Lambda expression:");
    Prog3 x = new Prog3(System.in);
    try {
      ASTStart z = x.Start();
	  System.out.println("The abstract syntax tree:");
      z.dump("");
	  System.out.println("");
	  System.out.println("The Lambda expression in the concrete syntax:");
	  System.out.println(z.printExpr());
	  System.out.println("");
	  System.out.println("The abstract syntax tree with free variables:");
	  z.dumpFV("");
    } catch (Exception e) {
      System.out.println("Error:");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}

PARSER_END(Prog3)


SKIP :
{
     " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN :
{
        <VAR: <LETTER> (<LETTER>|<DIGIT>)* >
    |
      < #LETTER: ["_","a"-"z"] >
    |
      < #DIGIT: ["0"-"9"] >
    |
        <CONSTANTS: "*"|"+"|"-"|"/"|(["0"-"9"])+>
}

ASTStart Start() : {/*@bgen(jjtree) Start */
  ASTStart jjtn000 = new ASTStart(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  Expression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Expression()       : {}
{ 
    constant() |
    var() | 
	"(" Branch() ")"
}

void Branch()       : {}
{
	(Appl() |
	 Lambda())
}

void Appl()       : {}
{
 ( Expression() (/*@bgen(jjtree) #Appl( 2) */
                 {
                   ASTAppl jjtn001 = new ASTAppl(JJTAPPL);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
                 }
                 try {
/*@egen*/Expression()/*@bgen(jjtree)*/
                 } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
                     jjtc001 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte001 instanceof RuntimeException) {
                     throw (RuntimeException)jjte001;
                   }
                   if (jjte001 instanceof ParseException) {
                     throw (ParseException)jjte001;
                   }
                   throw (Error)jjte001;
                 } finally {
                   if (jjtc001) {
                     jjtree.closeNodeScope(jjtn001,  2);
                   }
                 }
/*@egen*/         )* ) 
}

void Lambda()       : {}
{
 "L" body() 
}

void body()       : {}
{
 (var() (/*@bgen(jjtree) #Lambda( 2) */
         {
           ASTLambda jjtn001 = new ASTLambda(JJTLAMBDA);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
         }
         try {
/*@egen*/body()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
           }
         }
/*@egen*/           )) | 
 "."  Appl()
}

void var()      : {/*@bgen(jjtree) var */
                    ASTvar jjtn000 = new ASTvar(JJTVAR);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) var */
        try {
/*@egen*/ 
	t=<VAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  jjtn000.set(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void constant()           : {/*@bgen(jjtree) constant */
                              ASTconstant jjtn000 = new ASTconstant(JJTCONSTANT);
                              boolean jjtc000 = true;
                              jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) constant */
        try {
/*@egen*/ 
	t=<CONSTANTS>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{
	  jjtn000.set(t.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}